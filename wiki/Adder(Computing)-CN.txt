{{Quality|Unrated}}
{{av}}
:''有关蛇类物种，请参见[[Adder]]。''
{{Computing}}
理解加法原理对许多矮人[[computing|逻辑]]装置很重要。加法可用于装置中跟踪各种数值，例如[[stockpile|仓库]]中的物品数量、自特定事件以来经过的[[time|年]]数，或更抽象的计算。

处理二进制值时加法最简单。其他数字基数的加法也是可能的，但本文重点讨论二进制加法。加法需要选择任意数量的位数或数字进行加法，尽管大于加法器设计大小的数字可以通过顺序[[adder#Add_with_carry|带进位加法]]进行加法。出于本讨论的目的，最低有效位将被视为第一位或最右侧的数字。

在开始加法器之前，应该熟悉逻辑门NOT、OR、XOR和AND。这些门的描述可用于[[mechanical logic|机械]]、[[fluid logic|流体]]、[[creature logic|生物]]和[[animal logic|动物逻辑]]。加法还需要要加的值，这些值需要存储在某种[[memory (computing)|存储器]]中。

=增量=
简单的设计通常不需要完整的加法器，而只需要对某个值进行增量或减量——每次事件发生时从该值加或减一。

===1位增量===
最简单的增量是1位增量——即两个单位二进制值的加法。有两种可能性：0+1=1和1+1=10——但由于我们只有一个位，我们放弃更高的位，所以1+1=0。这个值表与NOT操作相同。请注意，我们的减量值表也与此相同——NOT既是1位增量又是1位减量。

===2位增量===
显然1位增量不是很有用。然而，我们可以通过考虑第1位的值轻松地从1位增量生成进位。当我们对第一位进行增量时，如果且仅当我们的第一位为1（真）时，它将生成影响第2位的进位，因此通过对第二位（更高有效位）与第一位进行异或运算，我们为第二位生成适当的值。重要的是要注意，这个异或运算必须对第一位的原始值执行，而不是对增量后的（NOT）值执行！

===2位减量===
对于2位，减量与加法略有不同，但差异不大。区别只是我们只有在第一位为0时才会生成进位！因此，我们的第二位变为[2]XOR(NOT[1])，而不是[2]XOR[1]。

===3位或更多位增量或减量===

当我们达到3位或更多位时，我们需要增加额外的复杂性层。考虑如果我们对1101进行增量会发生什么：如果我们只是[4]XOR[3]（第4位与第3位的异或），我们会错误地发现值为0110，而不是1110。我们需要使进位正确地通过系统传播。专用的增量器可以通过在每次从1变为0时对下一个更高位进行增量，但在从0变为1时不进行增量，将此功能构建到其位中。这个过程可以通过实现一个新的进位位，从右侧开始，使用以下算法进行逻辑描述（这不是任何特定语言，只是伪代码：）

 将[carry]设置为等于[1]  -- 如果我们的第一位为1，开始进位
 [1]变为等于NOT[1] -- 我们的第一位反转其值
 将n设置为2  -- 移动到下一个位位置
 当n<=位数时 -- 当我们还没有处理所有位时
   [n]变为等于[n]XOR[carry]  -- 如果我们有进位，则对下一位进行增量
   [carry]变为等于NOT[n]和[carry] -- 如果我们第n位的值已翻转，传播进位；否则，结束进位
   n变为等于n+1 -- 移动到下一个位位置
 结束

减量同样工作——唯一的区别是，如果且仅当某个位位置的值从0变为1时，我们才传播进位。

 将[carry]设置为等于NOT[1]  -- 如果我们的第一位为0，开始进位
 [1]变为等于NOT[1] -- 我们的第一位反转其值
 将n设置为2  -- 移动到下一个位位置
 当n<=位数时 -- 当我们还没有处理所有位时
   [n]变为等于[n]XOR[carry]  -- 如果我们有进位，则对下一位进行减量
   [carry]变为等于[n]和[carry] -- 如果我们第n位的值已翻转，传播进位；否则，结束进位
   n变为等于n+1 -- 移动到下一个位位置
 结束

有关基于生物逻辑的增量系统的示例，其增量构建到存储器中，请参见[[User:Vasiln/Goblin_Logic_1#Incrementing_memory_and_percolating_functions:_the_two-bit_add|此处]]。

===计数===
通常，增量系统不仅设计有输入，还有输出。这样的系统在每次接收到特定输入时进行增量，并在达到某个内部计数时输出。输出电路是二进制计数的简单问题。例如，在11次触发后输出的计数系统在第一位为1且第二位为1且第三位为0且第四位为1时输出。通常，输出也设计为重置计数，通过将计数的所有位写入0。

有关使用动物逻辑的增量系统的示例，请参见[[User:Bidok#Counter]]。[[User:Hussell/ClockToggle]]提供了完全流体实现。

===通过增量/减量进行加法===
可以通过重复增量一个值同时减量第二个值，直到第二个值达到零，来设计一个简单但缓慢的加法器。这样的系统需要某种[[repeater|中继器]]来驱动过程——每次中继器触发时，如果第二个值不等于零（第一位非且第二位非且第n位非），第一个值增量，第二个值减量。当第二个值达到零时，第一个值表示初始两个值的总和。

=加法=
在描述增量时，我们几乎描述了完整的加法。然而，加法的基础是异或运算，而不是非运算。

===1位加法===
在最简单的加法器中，我们考虑两个值。因此，我们现在有四种可能性：0+0=0，1+0=1，0+1=0，1+1=10=0。这是我们用异或运算得到的相同值表。因此，两个1位值的加法是对这两个值的异或运算。

===2位或更多位加法===
对于加法，我们需要在加第二位时实现进位值。我们的第一位是[1]XOR[1']——即我们的第一位的值与第1'位（第二个值中的第一位）的异或。然而，我们还需要从这个加法中生成一个进位值，它等于[1]AND[1']。为了得到第二位的值，我们首先加两个第二位，然后将结果与来自第一位的进位进行异或——因此2，我们的第二位，变为等于([2]XOR[b])XOR[carry]，或我们的进位与第一个值的第二位和第二个值的第二位的异或的异或。

这个算法可以推广到任何位长度的值。我们从右向左工作。在确定第2位的值之后，我们需要更新进位值，如果任何两个（或更多）异或的值（包括进位）等于1，它就变为1。也就是说，在完成第二位的值之后，我们将进位设置为等于(([2]OR[2'])AND([carry]))OR([2]AND[2'])。

考虑以下基于动物逻辑的9位加法器的美丽图像，注释表示每个数字的值：
<gallery>
Image:9bit adder prototype 10100010notes.PNG|更多信息请见[[User:LordOOTFD#Adders]]
</gallery>
http://mkv25.net/dfma/movie-1561-addingmachine 演示了一个6位机械加法器。http://mkv25.net/dfma/movie-1084-numberabbeydemonstration 演示了一个8位混合系统。

===n位减法===
减法同样与加法非常相似。然而，在这里我们必须考虑减法不具有交换性，因此我们必须考虑一个值从另一个值中减去。我们将考虑由n'位位置表示的第二个值为被减数，从第一个值（被减数）中减去的值。

同样，减法的基础是异或运算。考虑给定位的四种可能性：0-0=0，1-0=1，0-1=-1=1，1-1=0。区别在于我们如何处理进位。对于我们的第一个、最右侧的位，我们首先将进位设置为0（假）。之后，如果我们的进位和被减数都为1，或者如果我们的被减数为零且我们的进位或被减数为1，我们就生成进位。换句话说，我们第一位的进位等于([carry]AND[1'])OR(NOT[1]AND([carry]OR[1']))。这适用于任何长度的减法。

==带进位加法==
在前面的例子中，显然我们的值有翻转的风险。例如，将1加到1111会导致0。传统（非矮人）计算机通常同时具有加法和带进位加法功能。两者结合可以进行大于位长度的值的加法。

带进位加法从两个特定值的最低块的简单加法开始。例如，给定值000001和001111，我们可以从每个值的最低三位开始，001和111，将它们相加，结果为000。然而，对于我们的下一次加法，我们将保留由最后（第三）位的加法生成的进位，而不是在下一次进位开始时丢弃它。现在，我们加每个值的下三位（000和001），但包括来自我们前一次加法的进位。这些顺序加法给我们正确的值（010000），而不需要足够的位长度来以其他方式加每个值。

能够进行加法和带进位加法的系统被认为是完整的加法器。完整的加法器，即使是1位完整加法器，也可以加任何位长度的值。有关使用流体逻辑的示例，请参见[[User:Kyace/Adder]]。

==前瞻进位==
虽然简单的加法器能够进行可靠的加法，但它可能非常缓慢。考虑一个8位加法器：第8位的值取决于从第7位派生的进位，而第7位又取决于从第6位派生的进位，依此类推。整个加法必须按顺序执行，而不是并行加位。由于进位在值中波动的方式，这样的系统被称为''波动进位加法器''。当在电路中使用水或生物时，这可能意味着需要一天或更长时间来加两个8位值。然而，通过实现前瞻系统，可以大大改善这个过程，尽管复杂性会增加。

前瞻系统根据以下事实将值分解为位序列：如果第n位的两个值都为0（(NOT[n])AND(NOT[n'])），任何进位都将在该位结束，如果两个值都为1（[n]AND[n']），该位将生成进位。基于此，可以并行处理各种位长度的加法，基于进位不会传播超过进位结束位的知识。这可以大大改善加两个值所需的时间。

[[User:Jong/Dwarven_Computer|Jong的矮人计算机]]使用前瞻进行更快的加法，并能够进行带进位加法。该设计可以进一步压缩为非常紧凑和多功能的完整加法器：[[User:Larix/Adder]]。有关使用生物逻辑的示例，请参见[[User:Vasiln/Goblin_Logic_2#Look-ahead_Adder|前瞻加法]]。

==乘法和除法==
虽然超出了本文的范围，但可以使用类似的逻辑工具来乘或除两个值。在最简单（但最慢）的实现中，任何一个都可以通过顺序加法或减法来表示，将加法器与计数器集成。它也可以使用埃及乘法和除法来完成。
*[[User:BaronW]]的页面演示了这样一个令人敬畏的机械计算器的操作。

{{Category|Computing}}
[[ru:Adder (Computing)]]
